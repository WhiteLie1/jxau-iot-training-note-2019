== if判断语句

----
if 判断条件1:
    执行语句1……
elif 判断条件2:
    执行语句2……
elif 判断条件3:
    执行语句3……
else:
    执行语句4……
----

我在廖雪峰的网站看到一个人的错误，有必要提醒一下，`else` 后面不能跟条件判断语句，不然会报错 `SyntaxError: invalid syntax`

*语法错误：非法语法*

== 循环

for循环语法
----
for 变量 in 集合:
    循环体代码
----

完整的for循环语法
----
for 变量 in 集合:
    循环体代码
else:
    此处放，若没有通过break退出循环，则循环结束后，会执行的代码
----

== List列表
Python 内置的一种 *数据类型* 是列表： list

List 是一个可变的有序表，追加元素到末尾使用 `append()` 方法

----
>>> classmates.append('Adam')
>>> classmates
['Michael', 'Bob', 'Tracy', 'Adam']
----

把元素插入到指定的位置用 `insert()` 方法

----
>>> classmates.insert(1, 'Jack')
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']
----

删除 List 末尾的元素，用 `pop()` 方法

----
>>> classmates.pop()
'Adam'
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy']
----

删除指定位置的元素用 `pop(i)` 方法， i 是索引位置

----
>>> classmates.pop(1)
'Jack'
>>> classmates
['Michael', 'Bob', 'Tracy']
----

替换某个元素，可以直接对相应的索引位置赋值

----
>>> classmates[1] = 'Sarah'
>>> classmates
['Michael', 'Sarah', 'Tracy']
----

List 中的元素数据类型可以不同

----
>>> L = ['Apple', 123, True]
----

List 元素也可以是另一个 List

----
>>> s = ['python', 'java', ['asp', 'php'], 'scheme']
>>> len(s)
4
拆开写就是
>>> p = ['asp', 'php']
>>> s = ['python', 'java', p, 'scheme']
要拿到 'php' 可以写 p[1] 或者 s[2][1] ，因此 s 可以看成一个二维数组
----

== tuple元组

tuple 与 list 很相似，但是 tuple 一旦初始化就不能再修改

*tuple的陷阱：* 当你定义一个 tuple 时，在定义的时候， tuple 的元素就必须被确定下来，比如：

----
>>> t = (1, 2)
>>> t
(1, 2)
----

如果要定义一个 *空的* tuple，可以写成()：

----
>>> t = ()
>>> t
()
----

但是，要定义一个 *只有1个元素* 的 tuple ，如果你这么定义：

----
>>> t = (1)
>>> t
1
这样定义相当于将t变成了整型数据1
----

定义的不是 tuple，是 1 这个数！这是因为括号()既可以表示 tuple ，又可以表示数学公式中的小括号，这就产生了歧义，因此， Python 规定，这种情况下，按小括号进行计算，计算结果自然是1。

所以，只有1个元素的 tuple 定义时必须加一个逗号,，来消除歧义：

----
>>> t = (1,)
>>> t
(1,)
这样才是tuple型数据
----

Python 在显示只有1个元素的 tuple 时，也会加一个逗号，以免你误解成数学计算意义上的括号。

===== tuple到底变不变

----
>>> t = ('a', 'b', ['A', 'B'])
>>> t[2][0] = 'X'
>>> t[2][1] = 'Y'
>>> t
('a', 'b', ['X', 'Y'])
----

[NOTE]
====
表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！
====


== 字符串

=== 添加功能


加号产生一个新的列表

----
[1, 2, 3] + [4, 5, 6] = [1, 2, 3, 4, 5, 6]
----

extend()方法追加列表，将添加的参数传递给列表变量，不产生新的列表

----
list = [1, 2, 3]
list.extend([4, 5])  # 此时list内容为[1, 2, 3, 4, 5]
----

append()方法追加元素，不产生新的列表

----
list = [1, 2, 3]
list.append(0)       # 此时list内容为[1, 2, 3, 0]
list.append([4, 5])  # 此时list内容为[1, 2, 3, 0, [4, 5]]，将列表[4, 5]原封不动的传入
----

== 公共方法

=== python内置函数

.python包含了以下内置函数
[width = "100%", options="header"]
|==========================================
|   函数            |  描述                 | 备注
| len(item)         | 计算容器中元素的个数   |     
| del(item)         | 删除变量              | del有两种方式，使用关键字del或函数del()
| max(item)         | 返回容器中元素的最大值 | 如果是字典，只针对key比较
| min(item)         | 返回容器中元素的最小值 | 如果是字典，只针对key比较
|==========================================


== 变量进阶

=== 变量的引用

在 `python` 中

* *变量* 和 *数据* 是分开存储的

* *数据* 保存在内存中的一个位置

* *变量* 中保存着数据在内存中的 *地址*

* *变量* 中 *记录数据的地址*，就叫做 *引用*

* 使用 `id()` 函数可以查看变量中保存数据所在的 *内存地址*

注意：如果变量已被定义，对已定义变量的赋值，本质上是 *修改对数据的引用*

* *变量* 不再对之前的数据引用

* *变量* 改为对新赋值的数据引用

=== 可变类型与不可变类型

==== 不可变类型

内存中的数据不允许被修改，除非重新赋值分配新的内存地址

* 数字类型 `int`, `bool`, `float`, `complex`, `long(2.x)`

* 字符串 `str`

* 元组 `tuple`

==== 可变类型

内存中的数据可以使用对应的方法修改，而不改变其内存的地址
 
* 列表 `list`

* 字典 `dict`

==== 面试题

在python中，*列表变量* 调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用，即不会改变其内存的地址。

==== 函数的缺省参数

*指定函数的缺省参数*：在参数后使用赋值语句，可以指定参数的缺省值

----
def func(a, b = True):
    pass
----

*提示*：缺省参数，需要使用 *最常见的值* 作为默认值

缺省参数的注意事项：

定义的位置，必须保证带有默认值的缺省参数在 *参数列表末尾*

==== 多值参数

* 有时可能需要 *一个函数* 能够处理的参数 *个数* 是不确定的，这个时候，就可以用多值参数

* python中有两种多值参数：

1、参数名前增加 *一个* `*` 可以接受元组

2、参数名前增加 *两个* `*` 可以接受字典

* 一般在给多值参数命名时，习惯用以下两个名字

1、`\*args` -- 存放元组参数，前面有一个  `*`

2、 `\**kwargs` -- 存放字典参数，前面有两个星号

==== 浅拷贝与深拷贝

===== 浅拷贝

----
foo = [1, 2]
foo1 = foo
foo.append(3)
----

使用 `=` 赋值，结果是 `foo1` 与 `foo` 指向同一个内存地址，`foo` 改变，`foo1` 也跟着改变

===== 深度拷贝

----
foo = [1, 2]
foo1 = foo.copy()
foo.append(3)
----

使用 `copy()` 方法， 可以将 `foo` 的内容复制到一个新的内存地址，再让 `foo1` 指向它，改变 `foo` 的内容不会改变 `foo1` 的内容。


