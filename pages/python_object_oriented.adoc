== python面向对象

=== 面向对象三大特性

1、*封装* 根据 *职责* 将 *属性* 和 *方法* *封装* 到一个抽象的 *类* 中

* 定义类的准则

2、*继承* *实现代码的重用* ，相同的代码不需要重复的编写

* 设计类的技巧

* 子类针对自己特有的需求，编写特定的代码

3、*多态* 不同的 *子类对象* 调用相同的 *父类方法*，产生不同的执行结果

* *多态* 可以 *增加代码的灵活度*

* 以 *继承* 和 *重写父类方法* 为前提

* 是调用方法的技巧，*不会影响到类的内部设计*

=== 面向过程和面向对象基本概念

*1）面向过程 步骤*

1、把完成某一个需求的 `所有步骤` `从头到尾` 逐步实现

2、根据开发需求，将某些 *功能独立* 的代码 *封装* 成一个又一个 *函数*

3、最后要完成的代码，就是顺序地调用 *不同的函数*

*特点*

1、注重 *步骤与过程*，不注重职责分工

2、如果需求复杂，代码会变的很复杂

3、开发复杂项目，没有固定的套路，开发难度很大

*2）面向对象 步骤*

    相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法

1、在完成某个需求前，首先确定 *职责 -- 要做的事情（方法）*

2、根据 *职责* 确定不同的 *对象*，在 *对象* 内部封装不同的方法

3、最后要完成的代码，就是顺序的让 *不同的对象* 调用 *不同的方法*

*特点*

1、注重 *对象和职责*，不同的对象承担不同的职责

2、更加适合应对复杂的需求变化，*是专门应对复杂开发，提供的固定套路*

3、*需要在面向过程的基础上，再学习一些面向对象的语法*

=== 类和对象

*1）类*

* 首先看看定义，类是对一群具有 *相同特征* 或 *行为* 的事物的一个统称，是抽象的，*不能直接使用*

** *特征* 被称为 *属性*

** *行为* 被称为 *方法*

* 说的通俗点：*类* 就相当于制造飞机时的图纸，是一个 *模板*，是 *负责创建对象的*

*2）对象*

* *对象* 是 *由类创建出来的一个具体存在*，可以直接使用

** 拥有创建它的类的 *属性* 和 *方法*

* *对象* 就相当于用 *图纸制造* 的飞机

=== 内置方法和属性

[width = "100%" cols="4*^" options="header"]
|===========================
|序号       |方法名     |类型       |作用
|01         |__del__    |方法       |*对象被从内存中销毁前*，会被自动调用
|02         |__str__    |方法       |返回对象的描述信息，print函数输出使用
|===========================

=== 封装

1.*封装* 是面向对象编程的一大特点

2.面向对象编程的 *第一步* -- 将 *属性* 和 *方法* *封装* 到一个抽象的 *类* 中

3.*外界* 使用 *类* 创建 *对象*，然后 *让对象调用方法*

4.*对象方法的细节* 都被 *封装* 在 *类的内部*

一个对象的 *属性* 可以是 *另外一个类创建的对象*

=== 身份运算符

身份运算符用于 *比较* 两个对象的 *内存地址* 是否一致 -- *是否是同一个对象的引用*

* 在 `python` 中针对 `None` 比较时，建议使用 `is` 判断

* `is` 与 `==` 区别

** `is` 用于判断两个变量 *引用对象* 是否为同一个

** `==` 用于判断 *引用变量* 的值是否相等

[cols="3*^" options="header"]
|================================
|运算符     |描述       |实例
|is         |is是判断两个标识符是不是引用同一个对象 | x is y,类似 id(x) == id(y)
|is not     |is not是判断两个标识符是不是引用不同对象 | x is not y,类似 id(x) != id(y)
|================================
 
=== 继承

1）*继承的概念*：*子类* 拥有 *父类* 的所有 *方法* 和 *属性*

2）*继承的语法*：

----
class 类名(父类名):

    pass
----

* *子类* 中应该根据 *职责*，封装 *子类特有的* *属性和方法*

3）*继承的传递性*

*子类* 拥有 *父类* 以及 *父类的父类* 中封装的所有 *属性* 和 *方法*

=== 方法的重写

*应用场景*：当 *父类* 的方法实现不能满足子类需求时，可以对方法进行 *重写(override)*

*重写分两种情况*：

1.覆盖

* 在子类中 *重新编写* 父类的方法实现

* 重写后，在运行时只会调用 *子类* 中重写的方法，而不会再调用 *父类* 封装的方法

2.扩展

* 若在开发中，*子类的方法实现* 中 *包含 父类的方法实现*

** *父类原本封装的方法的实现* 是 *子类方法的一部分*

* 就可以使用 *扩展* 的方式

** 在子类中 *重写* 父类的方法

** 在需要的位置使用 `super().父类方法` 来调用父类方法的执行
 
** 代码其他的位置针对子类的需求，编写 *子类特有的代码实现*

=== 关于super

* 在 `Python` 中 `super` 是一个 *特殊的类*

* `super()` 就是使用 `super` 类创建出来的对象

* *最常* 使用的场景就是在 *重写父类方法时*，调用 *在父类中封装的方法实现*   

=== 模块

1）导入模块

----
import 模块名1
import 模块名2
----

导入后如果模块名太长，可以用 `as` 指定模块的名称，以方便使用

`import 模块1 as 模块别名`

注意：*模块别名* 应该符合 *大驼峰命名法*

2）from...import导入

* 如果希望 *从某一个模块* 中，导入 *部分* 工具，就可以使用 `from...import` 的方式

* `import 模块名` 是 *一次性* 把模块中 *所有的工具全部导入*，并且通过 *模块名/别名* 访问

----
# 从 模块 导入 某一个工具
from 模块名1 import 工具名
----

* 导入之后

** *不需要* 通过 `模块名.`

** 可以直接使用 *模块提供的工具* -- 全局变量、函数、类

注意：如果 *两个模块*，存在同名的函数，name后导入模块的函数，会覆盖掉先导入的函数

*from...import*

----
# 从 模块 导入 所有工具
from 模块名1 import *
----

=== 包

==== 概念

* *包* 是一个 *包含多个模块* 的 *特殊目录*

* 目录下有一个 *特殊的文件* `__init__.py`

* 包名的 *命名方式* 和变量名一致，小写字母 + `_`

==== 好处

* 使用 `import 包名` 可以一次性导入 *包* 中 *所有的模块*

=== 文件

==== 操作文件的套路

在计算机中要操作文件的套路非常固定，一共包含三个步骤：

1.打开文件

2.读、写文件

* *读* 将文件内容读入内存

* *写* 将内存内容写入文件

3.关闭文件

==== 操作文件的函数/方法

* 在 `Python` 中要操作文件需要记住1个函数和3个方法

[cols="3*^" options="header"]
|============================
|序号       |函数/方法      |说明
|01         |open           |打开文件，并且返回文件操作对象
|02         |read           |将文件内容读取到内存
|03         |write          |将指定内容写入文件
|04         |close          |关闭文件
|============================

* `open` 函数负责打开文件，并且返回文件对象

* `read`/`write`/`close` 三个方法都需要通过 *文件对象* 来调用

==== 打开文件的方式

* `open` 函数默认以 *只读方式* 打开文件，并且返回文件对象

语法为： `f = open("文件名", "访问方式")`

==== 按行读取文件内容

* `read` 方法默认会把文件的 *所有内容 一次性读取到内存*

* 如果文件太大，对内存的占用会非常严重

*readline 方法*

* `readline` 方法可以一次读取一行内容

* 方法执行后，会把 *文件指针* 移动到下一行，准备再次读取


==== eval函数

`eval()` 函数十分强大 -- *将字符串* 当成 *有效的表达式* 来求值 并 *返回计算结果*

